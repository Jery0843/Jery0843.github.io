---
title: "QLotto"
date: 2026-02-10T17:00:01Z
categories: [HackTheBox, Writeup]
tags: [htb, hackthebox, writeup, pentest, qlotto]
description: "HackTheBox QLotto machine writeup ‚Äî reconnaissance and enumeration walkthrough."
toc: true
comments: true
---


## Challenge Information

- **Name:** QLotto
- **Category:** Quantum
- **Difficulty:** Easy
- **Host:** 83.136.252.32:31179

## Challenge Description

*"They call it QLotto ‚Äî a dazzling new quantum lottery table provided by Qubitrix that lauders millions at the casino, where quantum draws decide your fate. If you can predict their draws, you can beat the system and clean out their coffers. Rig the jackpot, Operative. Every stolen coin funds their empire ‚Äî and every coin you steal funds our fight."*

## Initial Reconnaissance

### Analyzing the Provided Files

The challenge provides a single file: `server.py`. Let's examine its contents:

```bash
cat server.py
```

The server implements a quantum lottery system using Qiskit (IBM's quantum computing framework). Key observations:

1. **Quantum Circuit:** Uses 2 qubits (indices 0 and 1)
2. **Initial State:** Qubit 0 starts in superposition via `circuit.h(0)`
3. **User Input:** Players provide quantum gate instructions
4. **Measurement:** Both qubits are measured 36 times
5. **Number Generation:** 6 lottery numbers are extracted from the measurements

### Understanding the Code Flow

```python
def generate_circuit(self, instructions: str):
    circuit = QuantumCircuit(2)
    circuit.h(0)  # Qubit 0 in superposition
    
    instructions = instructions.split(";")
    for instr in instructions:
        parts = instr.split(":")
        gate, params = parts
        params = [ int(p) for p in params.split(",") ]
        
        # CRITICAL VALIDATION
        if any(p == 0 for p in params):
            print("[Dealer] Hey, don't tamper with the house card ‚Äî that's forbidden.")
            return None
```

**Key Restriction:** The validation `if any(p == 0 for p in params)` prevents us from using index `0` in our gate parameters.

### Available Gates

**Single-qubit gates (1 parameter):**
- `H` - Hadamard gate
- `S` - Phase gate
- `T` - T gate
- `Z` - Pauli-Z gate

**Two-qubit gates (3 parameters: angle, qubit1, qubit2):**
- `RXX` - Ising XX coupling gate
- `RYY` - Ising YY coupling gate
- `RZZ` - Ising ZZ coupling gate

### Understanding the Lottery Mechanism

```python
def extract_numbers(self, memory):
    for i in range(0, len(memory), 6):
        bits = memory[i : i + 6]  # 6 measurements
        
        lotto_number = ""
        testing_number = ""
        
        for testing_bit, lotto_bit in bits:
            lotto_number += str(lotto_bit)      # From qubit 0
            testing_number += str(testing_bit)  # From qubit 1
        
        lotto_number = int(lotto_number, 2) % 42 + 1
        testing_number = int(testing_number, 2) % 42 + 1
```

**Important Details:**
- Each measurement produces a 2-bit string (e.g., "01")
- In Qiskit's bit ordering: rightmost bit = qubit 0, leftmost bit = qubit 1
- `testing_numbers` come from qubit 1 (shown to player)
- `lotto_numbers` come from qubit 0 (hidden, must be guessed)
- 6 bits are combined to form each number: `int(binary, 2) % 42 + 1`

### Win Condition Analysis

```python
if lotto_numbers == testing_numbers:
    print("[Dealer] Trying to mirror the house's numbers, are we?")
    return

print(f"[Dealer] Your draws are: {testing_numbers}")
guess_numbers = input("[Dealer] Place your six bets on the table : ")

if guess_numbers == lotto_numbers:
    print(f"[Dealer] Your jackpot: {JACKPOT}")
```

**Requirements:**
1. `lotto_numbers` must NOT equal `testing_numbers` (anti-mirror check)
2. We see `testing_numbers` after circuit execution
3. We must predict `lotto_numbers` to win

## The Problem

We face a paradox:
- Qubit 0 (lottery) and Qubit 1 (testing) are independent by default
- We cannot use index `0` in our gate parameters
- We need to correlate the qubits to predict lottery numbers
- With only 2 qubits, any two-qubit gate must involve qubit 0
- But we can't reference qubit 0... or can we?

## Vulnerability Discovery

### Testing Basic Interactions

Let's test what happens with simple gates:

```bash
echo "H:1" | nc 83.136.252.32 31179
```

**Output:**
```
[Dealer] Your draws are: [29, 10, 12, 23, 36, 13]
```

Both qubits in superposition produces random, uncorrelated numbers.

### Exploring Edge Cases

What if we try using qubit index 2?

```bash
echo "H:2" | nc 83.136.252.32 31179
```

**Output:**
```
[Dealer] Card numbers must be less than 2
```

Confirmed: only 2 qubits (indices 0 and 1) exist.

### The Breakthrough: Negative Indexing

Python supports negative indexing where `-1` refers to the last element. Let's test:

```bash
echo "H:-1" | nc 83.136.252.32 31179
```

**Output:**
```
[Dealer] Your draws are: [39, 15, 41, 16, 26, 37]
```

It works! `-1` maps to qubit 1. Now the critical test:

```bash
echo "H:-2" | nc 83.136.252.32 31179
```

**Output:**
```
[Dealer] The draw fizzles... not enough quantum energy in your play.
```

**Eureka!** The entropy validation failed, meaning we affected qubit 0! The check `if any(p == 0 for p in params)` only checks for equality with `0`, not negative numbers.

**Negative Index Mapping:**
- `-1` ‚Üí Qubit 1 (last qubit)
- `-2` ‚Üí Qubit 0 (second to last qubit)

### Testing Two-Qubit Gates

Now we can use two-qubit gates with indices `1` and `-2`:

```bash
echo "RXX:180,1,-2" | nc 83.136.252.32 31179
```

**Output:**
```
[Dealer] Your draws are: [22, 22, 22, 22, 22, 22]
```

Interesting! All testing numbers are identical, suggesting strong correlation.

## Quantum Mechanics Deep Dive

### Understanding Entanglement

Our goal is to create a quantum state where measuring qubit 1 allows us to predict qubit 0's measurement.

**Initial State (after default H gate on qubit 0):**
```
|œà‚ÇÄ‚ü© = |+‚ü©|0‚ü© = (|0‚ü© + |1‚ü©)/‚àö2 ‚äó |0‚ü© = (|00‚ü© + |10‚ü©)/‚àö2
```

### Building the Exploit Circuit

We need to create **anti-correlated entanglement** where:
- If qubit 1 measures `0`, qubit 0 measures `1`
- If qubit 1 measures `1`, qubit 0 measures `0`

**Step 1: Reset Qubit 0**
```
H:-2
```
Applying Hadamard to qubit 0 (already in |+‚ü©) collapses it to |0‚ü©.

**State:** `|00‚ü©`

**Step 2: Create Correlation**
```
RXX:90,-1,-2
```
The RXX gate with Œ∏=90¬∞ creates entanglement:
```
RXX(œÄ/2)|00‚ü© = (|00‚ü© - i|11‚ü©)/‚àö2
```

**State:** Both qubits are now correlated (both 0 or both 1).

**Step 3: Flip Qubit 1**
```
H:-1;Z:-1;H:-1
```
This sequence implements an X (NOT) gate on qubit 1:
```
X = HZH
```

**Final State:** `(|01‚ü© - i|10‚ü©)/‚àö2`

Now the qubits are **anti-correlated**!

### Complete Instruction Payload

```
H:-2;RXX:90,-1,-2;H:-1;Z:-1;H:-1
```

## Mathematical Analysis

### Bit Relationship

With anti-correlated qubits:
- Measurement "01" ‚Üí testing_bit=0, lotto_bit=1
- Measurement "10" ‚Üí testing_bit=1, lotto_bit=0

For each 6-bit number:
```
testing_bits = b‚ÇÖb‚ÇÑb‚ÇÉb‚ÇÇb‚ÇÅb‚ÇÄ
lotto_bits   = bÃÑ‚ÇÖbÃÑ‚ÇÑbÃÑ‚ÇÉbÃÑ‚ÇÇbÃÑ‚ÇÅbÃÑ‚ÇÄ  (inverted)
```

### Number Calculation

```python
testing_num = int(testing_bits, 2) % 42 + 1
lotto_num = int(lotto_bits, 2) % 42 + 1
```

Since lotto_bits are inverted:
```
int(lotto_bits, 2) = 63 - int(testing_bits, 2)  # 63 = 0b111111
```

Therefore:
```
lotto_num = (63 - int(testing_bits, 2)) % 42 + 1
         = (63 - (testing_num - 1)) % 42 + 1
```

**Final Formula:**
```python
lotto_num = (63 - (testing_num - 1)) % 42 + 1
```

---

<div class="paywall-section">
  <div class="paywall-fade"></div>
  <div class="paywall-cta">
    <div class="paywall-icon">üîí</div>
    <h3>Premium Content</h3>
    <p>The full exploitation walkthrough, privilege escalation, and flags are available exclusively for members.</p>
    <a href="https://whop.com/andres-411f/" target="_blank" rel="noopener" class="paywall-btn">
      Unlock Full Writeup ‚Üí
    </a>
  </div>
</div>
